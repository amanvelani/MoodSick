import os
import requests
from fastapi import HTTPException, APIRouter, Request
from httpx import AsyncClient
from .import admin, users
import base64
from pydantic import BaseModel
from enum import Enum
import json
import numpy as np
import urllib.parse


router = APIRouter()

spotify_user_id = os.getenv("SPOTIFY_USER_ID")
spotify_client_id = os.getenv("SPOTIFY_CLIENT_ID")
spotify_client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
moodsick_authorization_code = os.getenv("SPOTIFY_ACCESS_TOKEN")
user_redirect_uri = os.getenv("SPOTIFY_USER_REDIRECT_URI")
scopes = os.getenv("SPOTIFY_SCOPES")

base_categories = {
    "rock": ["alt-rock", "alternative", "british", "emo", "garage", "grunge", "hard-rock", "indie", "indie-pop", "j-rock", "psych-rock", "punk", "punk-rock", "rock", "rock-n-roll", "rockabilly"],
    "hip-hop": ["hip-hop"],
    "blues": ["blues"],
    "jazz": ["bossanova", "jazz"],
    "classical": ["classical", "opera"],
    "metal": ["black-metal", "death-metal", "heavy-metal", "metal", "metal-misc", "metalcore"],
    "reggae": ["reggae", "dancehall"],
    "country": ["bluegrass", "country", "honky-tonk"],
    "pop": ["cantopop", "disney", "j-pop", "k-pop", "latin", "latino", "mandopop", "pop", "pop-film", "power-pop", "synth-pop"],
    "disco": ["disco"]
}

class SongFeature(BaseModel):
    uri : str
    genre : list
    popularity : str 

class SpotifyPlaylist(Enum):
    AGE_10_20 = "2fVLPnOhxdWUJgIQNL3bTw"
    AGE_20_30 = "3cdJfW7OhCw6vl8CUP0Dsj"
    AGE_30_40 = "3VufVRa2CfR04x50ePLFER"
    AGE_40_50 = "2lyDBxRyHXRH5t5gHdTXXj"
    AGE_50_60 = "2Px1aIIcmJhWdYsiQhZePz"

class ModelParams(BaseModel):
    min_danceability: float
    max_danceability: float
    target_danceability: float
    min_energy: float
    max_energy: float
    target_energy: float
    min_key: int
    max_key: int
    target_key: int
    min_loudness: float
    max_loudness: float
    target_loudness: float
    min_mode: int
    max_mode: int
    target_mode: int
    min_speechiness: float
    max_speechiness: float
    target_speechiness: float
    min_acousticness: float
    max_acousticness: float
    target_acousticness: float
    min_instrumentalness: float
    max_instrumentalness: float
    target_instrumentalness: float
    min_liveness: float
    max_liveness: float
    target_liveness: float
    min_valence: float
    max_valence: float
    target_valence: float
    min_tempo: int
    max_tempo: int
    target_tempo: int
    min_time_signature: int
    max_time_signature: int
    target_time_signature: int
    genre: str
    sort_by_popularity: bool


async def read_spotify_profile_user(user_token: str):
    url = 'https://api.spotify.com/v1/me'
    headers = {'Authorization': f"Bearer {user_token}"}

    async with AsyncClient() as client:
        response = await client.get(url, headers=headers)
        
        if response.status_code != 200:
            raise HTTPException(status_code=response.status_code, detail=response.text)

        return response.json().get("id"), response.json().get("display_name")

# @router.get("/create-playlist")
# async def create_user_playlist(user_token: str, user_id: int):
#     # Get the user id and name
#     spotify_user_id, spotify_user_name = await read_spotify_profile_user(user_token)
#     # print(spotify_user_id, spotify_user_name)
#     endpoint_url_user = f"https://api.spotify.com/v1/users/{spotify_user_id}/playlists"
#     user_playlist_name = "MoodSick Playlist for " + spotify_user_name + "!"
#     user_description = "Playlist generated by MoodSick"

#     request_body = json.dumps({
#         "name": user_playlist_name,
#         "description": user_description,
#         "public": False # let's keep it between us - for now
#     })
#     # Get the user playlist uri after creating the playlist
#     response = requests.post(url = endpoint_url_user, data = request_body, headers={"Content-Type":"application/json", "Authorization": f"Bearer {user_token}"})
#     # print(response.json())
#     # Save the user playlist uri to the mongodb database
#     users.save_user_playlist(user_id, response.json().get("uri"))
    
#     return response.json().get("uri")


# This function is used to get the spotify recommendations based on the parameters passed by the model
@router.post("/spotify-recommendations")
async def get_spotify_recommendations(request: ModelParams):
    user_token = await users.get_user_spotify_token()
    moodsick_token = await admin.get_moodsick_spotify_token()
    url = 'https://api.spotify.com/v1/recommendations'
    headers = {
        'Authorization': f"Bearer {user_token}"  # Replace with your actual token
    }
    seed_genres = request.genre
    genres = seed_genres.split(",")
    print(seed_genres)
    sampled_genres = ",".join([np.random.choice(base_categories[genre]) for genre in genres])
    print(f"Original genres: {seed_genres}, sampled genres: {sampled_genres}")
    limit = 20
    sort_by_popularity = request.sort_by_popularity
    # The following params are cauing the api to fail: mode, key, time_signature
    params_target = {
        'seed_genres': sampled_genres,
        'limit': limit,
        'target_danceability': request.target_danceability,
        'target_energy': request.target_energy,
        'target_loudness': request.target_loudness,
        'target_speechiness': request.target_speechiness,
        'target_acousticness': request.target_acousticness,
        'target_instrumentalness': request.target_instrumentalness,
        'target_liveness': request.target_liveness,
        'target_valence': request.target_valence,
        'target_tempo': request.target_tempo,
    }
    params_min_max = {
        'seed_genres': sampled_genres,
        'limit': limit,
        'min_danceability': request.min_danceability,
        'max_danceability': request.max_danceability,
        'min_energy': request.min_energy,
        'max_energy': request.max_energy,
        'min_loudness': request.min_loudness,
        'max_loudness': request.max_loudness,
        'min_speechiness': request.min_speechiness,
        'max_speechiness': request.max_speechiness,
        'min_acousticness': request.min_acousticness,
        'max_acousticness': request.max_acousticness,
        'min_instrumentalness': request.min_instrumentalness,
        'max_instrumentalness': request.max_instrumentalness,
        'min_liveness': request.min_liveness,
        'max_liveness': request.max_liveness,
        'min_valence': request.min_valence,
        'max_valence': request.max_valence,
        'min_tempo': request.min_tempo,
        'max_tempo': request.max_tempo,
    }

    async with AsyncClient() as client:
        response = await client.get(url, headers=headers, params=params_min_max)
        print(response.json())
        if(len(response.json().get("tracks")) == 0 or response.status_code != 200):
            response = await client.get(url, headers=headers, params=params_target)
            if(len(response.json().get("tracks")) == 0):
                raise HTTPException(status_code=500, detail="No tracks found")
        
        if response.status_code != 200:
            raise HTTPException(status_code=response.status_code, detail=response.text)

        responseJson = response.json()
        # print(f"Final response: {responseJson}")
        # Dict to save the track uri and popularity
        track_uris = {}
        for each in range(len (responseJson["tracks"])):
            del responseJson["tracks"][each]["available_markets"]
            # del responseJson["tracks"][each]["album"]
            track_uris[responseJson["tracks"][each]["uri"]] = responseJson["tracks"][each]["popularity"]
            # track_uris.append(responseJson["tracks"][each]["uri"])
        
        # track_features = await get_track_features(user_token, track_uris)
        # print(track_features)
        # return track_features

        if sort_by_popularity:
            # Sort the tracks based on popularity
            track_uris = sorted(track_uris, key=track_uris.get, reverse=True)
            # Get top 5 tracks
            track_uris = track_uris[:5]
        else:
            # Choose 5 random tracks
            track_uris = np.random.choice(list(track_uris.keys()), 5, replace=False).tolist()

        # Check if the user has a playlist
        # If the user has a playlist, save the tracks to the playlist
        # If the user does not have a playlist, create a playlist and save the tracks to the playlist
        # user_playlist_uri = users.get_user_playlist(user_id=1)
        # if user_playlist_uri is None:
        #     user_playlist_uri = await create_user_playlist(user_token=user_token, user_id=1)

        # user_playlist_uri = user_playlist_uri.split(":")[-1]
        user_playlist_uri = "2vsbJJ1WUEp0D9Nwa4wdzH"
        # Save the tracks to the user playlist
        await save_to_user_playlist(user_token, track_uris, user_playlist_uri)
        # Save the tracks to the moodsick playlist according to user's age
        user_age = 23
        await save_to_moodsick_playlist(user_age, moodsick_token, track_uris)
        # return response.json()
        return responseJson


# async def get_track_features(user_token, track_uris):
#     # Split each uri like this user_playlist_uri.split(":")[-1]
#     api_track_uri = ",".join([uri.split(":")[-1] for uri in track_uris])
#     enpoint_url = "https://api.spotify.com/v1/tracks"
#     headers = {
#         'Authorization': f"Bearer {user_token}"
#     }
#     data = {
#         "ids" : api_track_uri
#     }
#     async with AsyncClient() as client:
#         track_features = []
#         response = await client.get(enpoint_url, headers=headers, params=data)
#         print("Inside Get Track Features")
#         if response.status_code != 200:
#             raise HTTPException(status_code=response.status_code, detail=response.text)
        
#         responseJson = response.json()
#         # for each in range(len(responseJson["tracks"])):
#         #     print(responseJson["tracks"][each]["artists"][0]["genres"])
#         #     track_features.append(SongFeature(uri=responseJson["tracks"][each]["uri"], genre=responseJson["tracks"][each]["artists"][0]["genres"], popularity=responseJson["tracks"][each]["popularity"]))
        
#         return responseJson


async def save_to_user_playlist(user_token, track_uris, user_playlist_link):
    endpoint_url_user = f"https://api.spotify.com/v1/playlists/{user_playlist_link}/tracks"

    headers = {
        'Authorization': f"Bearer {user_token}",
        'Content-Type': 'application/json'
    }

    data = {
        "uris": track_uris,
        "position": 0
    }

    async with AsyncClient() as client:
        # response = await client.post(endpoint_url, headers=headers, json=data)
        response_personal = await client.post(endpoint_url_user, headers=headers, json=data)
        if response_personal.status_code != 201:
            raise HTTPException(status_code=response_personal.status_code, detail=response_personal.text)
        
        return response_personal.json()
    
async def save_to_moodsick_playlist(age, moodsick_token, track_uris):
    # Get playlist id based on age
    if age < 20:
        playlist_id = SpotifyPlaylist.AGE_10_20.value
    elif age < 30:
        playlist_id = SpotifyPlaylist.AGE_20_30.value
    elif age < 40:
        playlist_id = SpotifyPlaylist.AGE_30_40.value
    elif age < 50:
        playlist_id = SpotifyPlaylist.AGE_40_50.value
    else:
        playlist_id = SpotifyPlaylist.AGE_50_60.value
    
    endpoint_url_mooksick = f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks"

    headers = {
        'Authorization': f"Bearer {moodsick_token}",
        'Content-Type': 'application/json'
    }

    data = {
        "uris": track_uris,
        "position": 0
    }

    async with AsyncClient() as client:
        response_moodsick = await client.post(endpoint_url_mooksick, headers=headers, json=data)
        if response_moodsick.status_code != 201:
            raise HTTPException(status_code=response_moodsick.status_code, detail=response_moodsick.text)
        
        return response_moodsick.json()